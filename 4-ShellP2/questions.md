1. Can you think of why we use `fork/execvp` instead of just calling `execvp` directly? What value do you think the `fork` provides?

    > **Answer**:  We use fork/execvp because fork creates a copy of the current process, allowing the child process to execute the new program using execvp. The fork allows for the process to be isolated and for the base program to continue running parallel to the subprocess.

2. What happens if the fork() system call fails? How does your implementation handle this scenario?

    > **Answer**:   the fork() system call fails, it returns a negative value. My implementation handles this scenario by printing an error message and returning ERR_EXEC_CMD.

3. How does execvp() find the command to execute? What system environment variable plays a role in this process?

    > **Answer**:  execvp() finds the command to execute by searching the directories listed in the PATH environment variable.

4. What is the purpose of calling wait() in the parent process after forking? What would happen if we didnâ€™t call it?

    > **Answer**:  Calling wait() in the parent process after forking is to wait for the child process to finish before continuing. If it wasn't called, the parent process would just continue and potentially cause unexpected errors.

5. In the referenced demo code we used WEXITSTATUS(). What information does this provide, and why is it important?

    > **Answer**:  WEXITSTATUS() provides the exit code of the child process. This is important because it allows the parent process to know whether the executed command succeeded or failed.

6. Describe how your implementation of build_cmd_buff() handles quoted arguments. Why is this necessary?

    > **Answer**:  build_cmd_buff() handles quoted arguments by detecting quote characters, then treating everything between the quotes as a single argument, preserving spaces within using a bool to track the quoted state (true or false). This is necessary to allow arguments containing spaces to be passed correctly to commands.

7. What changes did you make to your parsing logic compared to the previous assignment? Were there any unexpected challenges in refactoring your old code?

    > **Answer**:  I had to rework virtually most of my parsing logic to match the new format. The unexpected challenge was that this has taken me significantly longer.

8. For this quesiton, you need to do some research on Linux signals. You can use [this google search](https://www.google.com/search?q=Linux+signals+overview+site%3Aman7.org+OR+site%3Alinux.die.net+OR+site%3Atldp.org&oq=Linux+signals+overview+site%3Aman7.org+OR+site%3Alinux.die.net+OR+site%3Atldp.org&gs_lcrp=EgZjaHJvbWUyBggAEEUYOdIBBzc2MGowajeoAgCwAgA&sourceid=chrome&ie=UTF-8) to get started.

- What is the purpose of signals in a Linux system, and how do they differ from other forms of interprocess communication (IPC)?

    > **Answer**:  Signals in a Linux system are used for communication between processes to notify processes of events. They differ from other IPC methods because they're asynchronous and interrupt-driven, rather than requiring explicit data exchange to function.

- Find and describe three commonly used signals (e.g., SIGKILL, SIGTERM, SIGINT). What are their typical use cases?

    > **Answer**:  SIGKILL (9) immediately terminates a process. SIGTERM (15) requests a process to terminate gracefully. SIGINT (2) is generated by pressing Ctrl+C, requesting interruption.

- What happens when a process receives SIGSTOP? Can it be caught or ignored like SIGINT? Why or why not?

    > **Answer**:  When a process receives SIGSTOP, it is paused and stops execution until resumed with SIGCONT. Unlike SIGINT, SIGSTOP cannot be caught or ignored because it is managed directly by the kernel for process control.
